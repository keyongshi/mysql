## 常见索引数据结构
B+树，红黑树，跳表，AVL的对比分析
### B+树
B和B+主要用在文件系统以及数据库中做索引等，比如Mysql
相对红黑树，B树更适合大数据量的索引结构
- 针对硬盘的顺序读写速度优于随机读写速度
- 磁盘I/O相对于内存速度存在量级上的差距，B-tree整棵树存储在硬盘，节点读写时加载到内存
- B-Tree的多叉树结构相对于二叉树，高度更低，也就是有效的 减少了I/O次数，尤其是B+树
### 红黑树
平衡二叉树，广泛用在C++的STL中。
追求局部而不是非常严格整体平衡。
相对B树，平衡二叉树适用于存储的数据量较小，整颗树存储到内存，因为内存中随机读写与顺序读写速度相当，所以二叉树和B树在使用场景上就不同
红黑树的应用就很多了，除了上面同学提到的STL，还有
epoll在内核中的实现，用红黑树管理事件块
nginx中，用红黑树管理timer等
Java的TreeMap实现
著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块

### B+树和红黑树

局部性原理造成这样的差异。B-tree可以以块为单位存到外存，AVL树不好存到外存，就算存到外存如果不能全部加载到内存，在利用AVL树搜索的过程中就可能需要多次磁盘IO。又因为外存往往大于内存，所以就有“B-tree存储的数据量大“的错觉，其实应该说“B-tree适合做大数据量的索引结构”比较合适一些。

### skiplist
在server端，对并发和性能有要求的情况下，如何选择合适的数据结构（这里是跳跃表和红黑树）。
如果单纯比较性能，跳跃表和红黑树可以说相差不大，但是加上并发的环境就不一样了，
如果要更新数据，跳跃表需要更新的部分就比较少，锁的东西也就比较少，所以不同线程争锁的代价就相对少了，
而红黑树有个平衡的过程，牵涉到大量的节点，争锁的代价也就相对较高了。性能也就不如前者了。
在并发环境下skiplist有另外一个优势，红黑树在插入和删除的时候可能需要做一些rebalance的操作，这样的操作可能会涉及到整个树的其他部分，
而skiplist的操作显然更加局部性一些，锁需要盯住的节点更少，因此在这样的情况下性能好一些。

Redis使用了skiplist来实现sorted set
### AVL
最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树。
AVL是一种高度平衡的二叉树，所以通常的结果是，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多。
当然，如果场景中对插入删除不频繁，只是对查找特别有要求，AVL还是有优势的

### Trie树
字典树，用在统计和排序大量字符串
一个典型应用是前缀匹配，比如在我们输入时，搜索引擎会给予提示；还有IP选路，也是前缀匹配，一定程度会用到trie
