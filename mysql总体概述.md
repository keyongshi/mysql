# mysql总体概述

对于绝大部分开发同学来说，mysql遇到的第一个问题就是：平时用的msyql是用的什么引擎，为什么选择这个引擎。

## 存储引擎

### InnoDB

默认事务型引擎，默认隔离级别是RR。InnoDB是目前最流行的引擎，如果没有特殊说明，都是指InnoDB引擎。
- 特性
    - 具有较好的事务支持：支持4个事务隔离级别，支持多版本读
    - 行级锁定：通过索引实现，实现成本大，但是锁定粒度小，对提高并发性非常有帮助。全表扫描仍然会是表锁，注意间隙锁(gap锁)的影响
    - 读写阻塞与事务隔离级别相关
    - 具有非常高效的缓存特性：能缓存索引，也能缓存数据
    - 整个表和主键以Cluster方式存储，组成一颗平衡树
    - 所有Secondary Index都会保存主键信息
- 适用场景
    - 需要事务支持（具有较好的事务特性）
    - 行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成
    - 数据更新较为频繁的场景
    - 数据一致性要求较高
    - 硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，尽可能减少磁盘IO
- 最佳实践
    - 主键尽可能小，提高查询索引速度，也避免给Secondary index带来过大的空间负担
    - 避免全表扫描，全表扫描会使用表锁，IO也很大
    - 尽可能缓存所有的索引和数据，提高响应速度
    - 在大批量小插入的时候，尽量自己控制事务而不要使用autocommit自动提交，原理类似于pipeline
    - 合理设置innodb_flush_log_at_trx_commit参数值，不要过度追求安全性，发挥批量的优势
    - 避免主键更新，因为这会带来大量的数据移动（聚簇索引变化）

### MyISAM

- 特性
  - 不支持事务：MyISAM存储引擎不支持事务，所以对事务有要求的业务场景不能使用
  - 表级锁定：其锁定机制是表级索引，这虽然可以让锁定的实现成本很小但是也同时大大降低了其并发性能
  - 读写互相阻塞：读取时加共享锁，写入时对表加排它锁，不仅会在写入的时候阻塞读取，MyISAM还会在读取的时候阻塞写入，但读本身并不会阻塞另外的读
  - 只会缓存索引：MyISAM可以通过key_buffer缓存以大大提高访问性能减少磁盘IO，但是这个缓存区只会缓存索引，而不会缓存数据
- 使用场景
  - 不需要事务支持（不支持）
  - 并发相对较低（锁定机制问题）
  - 数据修改相对较少（阻塞问题）
  - 以读为主
  - 数据一致性要求不是非常高
- 最佳实践
  - 尽量索引（缓存机制）
  - 调整读写优先级，根据实际需求确保重要操作更优先
  - 启用延迟插入改善大批量写入性能
  - 尽量顺序操作让insert数据都写入到尾部，减少阻塞
  - 分解大的操作，降低单个操作的阻塞时间
  - 降低并发数，某些高并发场景通过应用来进行排队机制
  - 对于相对静态的数据，充分利用Query Cache可以极大的提高访问效率
  - MyISAM的Count只有在全表扫描的时候特别高效，带有其他条件的count都需要进行实际的数据访问

### 其他存储引擎

- NDBCluster
- Archive引擎
- Memory引擎

### 如何选择引擎

一般是在InnoDB和MyISAM引擎中选择，如果需要事务，选择InnoDB，如果不需要事务，且主要是select和insert操作，那么可以考虑使用MyISAM。

## MVCC 多版本并发控制(Multi-Version Concurrency Control) 

基于提升并发性能的考虑，mysql数据库引入了多版本并发控制（MVCC）。MVCC是一种无锁的事务机制，也称为mysql的乐观机制。可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。

它最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。

通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。

根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

不同的引擎的MVCC实现是不同的，InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建版本号，一个保存了行的过期版本号。

每开始一个新的事务，系统版本号都会自动递增。通过判断当前版本与数据行的创建版本号和过期版本号判断是否能读取该数据行。

在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。
- 快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。
  以下语句是快照读
```
select * from table where ?
```
- 当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。
  以下语句都是当前读
```
select * from table where ? lock in share mode;
select * from table where ? for update;
insert into table values (…);
update table set ? where ?;
delete from table where ?;
```

MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。

以InnoDB下默认的事务隔离级别REPEATABLE READ来说，MVCC工作如下：
- SELECT----InnoDB会根据以下两个条件检查每行记录：1. InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始之前已经存在的，要么是事务自身插入或者修改过的；2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
- INSERT----InnoDB为新插入的每一行保存当前系统版本号作为行版本号。
- DELETE----InnoDB为删除的每一行保存当前系统版本号作为删除标示。
- UPDATE----InnoDB会插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标示。


MVCC扩展阅读：[多版本并发控制(MVCC)在分布式系统中的应用](http://coolshell.cn/articles/6790.html)

## 事务隔离级别（isolation level）

InnoDB引擎的前提下：
- Read Uncommitted，可以读取未提交记录。此隔离级别，不会使用，忽略。
- Read Committed（RC），针对当前读，RC隔离级别保证对读取到的记录加锁 (记录锁)，存在幻读现象。
- Repeatable Read（RR），针对当前读，RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，不存在幻读现象。
- Serializable，从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。

## 并发控制

### 读写锁

- 共享锁（shared lock），也称为读锁（S锁）
- 排它锁（exclusive lock），也成为写锁（X锁）

读锁是共享的，或者说是相互不阻塞的。写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。

### 锁粒度

- 表锁（table lock）
- 行级锁（row lock）

表锁是mysql中最基本的策略，并且是开销最小的策略。

行级锁可以最大程度地支持并发处理，同时也带来了最大的锁开销。

### GAP锁
GAP锁不是加在记录上的，而是加在两条记录之间的位置

GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。

所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id = 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。

如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。




### 如何知道需要优化哪些sql

- 慢查询日志
- show full processlist
- 抓取tcp网络包



### 剖析单条查询
#### 使用explain

explain select ...

#### 使用show profile

set profiling = 1;

select …..

show profiles;

show profile for query 1


## 高性能

优化方向
1. 减少IO次数
2. 减少cpu计算

优化思路：
库表结构优化，索引优化，查询优化三者齐头并进，才能追求到高性能。
1. schema结构的优化

     字段优化，例如clip url索引改为md5之后再索引，能用small int的就不用int

     分区，数据更聚集

     冗余，减少表关联

     索引优化，尽量用复合索引
2. sql优化

   如何利用索引

   如何利用小表limit出结果后再关联大表获取到最终结果

   like的优化

   order by的优化

   or改为union的优化
3. 最终是通过减少IO次数来提升sql执行效率
4. 减少cpu计算，order by， group by等都是cpu计算大户
5. 优化频繁执行的sql，而不是某些频率低的“大”SQL






