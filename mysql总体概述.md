# mysql架构与历史


## 并发控制

### 读写锁

- 共享锁（shared lock），也称为读锁
- 排它锁（exclusive lock），也成为写锁

读锁是共享的，或者说是相互不阻塞的。写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。

### 锁粒度

- 表锁（table lock）
- 行级锁（row lock）

表锁是mysql中最基本的策略，并且是开销最小的策略。

行级锁可以最大程度地支持并发处理，同时也带来了最大的锁开销。

## 事务隔离级别

- Read Uncommitted（RU）
- Read Committed（RC）
- Repeatable Read（RR）
- Serializable（Se）



## MVCC 多版本并发控制

通过保存数据在某个时间点的快照来实现的。

也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。

根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

不同的引擎的MVCC实现是不同的，InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建版本号，一个保存了行的过期版本号。

每开始一个新的事务，系统版本号都会自动递增。

## 存储引擎

### InnoDB

默认事务型引擎，默认隔离级别是RR。
- 特性

    - 具有较好的事务支持：支持4个事务隔离级别，支持多版本读

    - 行级锁定：通过索引实现，全表扫描仍然会是表锁，注意间隙锁的影响

    - 读写阻塞与事务隔离级别相关

    - 具有非常高效的缓存特性：能缓存索引，也能缓存数据

    - 整个表和主键以Cluster方式存储，组成一颗平衡树

    - 所有Secondary Index都会保存主键信息

- 适用场景

    - 需要事务支持（具有较好的事务特性）

    - 行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成

    - 数据更新较为频繁的场景

    - 数据一致性要求较高

    - 硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，尽可能减少磁盘 IO

- 最佳实践

    - 主键尽可能小，避免给Secondary index带来过大的空间负担

    - 避免全表扫描，因为会使用表锁

    - 尽可能缓存所有的索引和数据，提高响应速度

    - 在大批量小插入的时候，尽量自己控制事务而不要使用autocommit自动提交

    - 合理设置innodb_flush_log_at_trx_commit参数值，不要过度追求安全性

    - 避免主键更新，因为这会带来大量的数据移动

### MyISAM

- 特性
  - 不支持事务：MyISAM存储引擎不支持事务，所以对事务有要求的业务场景不能使用

  - 表级锁定：其锁定机制是表级索引，这虽然可以让锁定的实现成本很小但是也同时大大降低了其并发性能

  - 读写互相阻塞：读取时加共享锁，写入时对表加排它锁，不仅会在写入的时候阻塞读取，MyISAM还会在读取的时候阻塞写入，但读本身并不会阻塞另外的读

  - 只会缓存索引：MyISAM可以通过key_buffer缓存以大大提高访问性能减少磁盘IO，但是这个缓存区只会缓存索引，而不会缓存数据
- 使用场景
  - 不需要事务支持（不支持）

  - 并发相对较低（锁定机制问题）

  - 数据修改相对较少（阻塞问题）

  - 以读为主

  - 数据一致性要求不是非常高
- 最佳实践
  - 尽量索引（缓存机制）

  - 调整读写优先级，根据实际需求确保重要操作更优先

  - 启用延迟插入改善大批量写入性能

  - 尽量顺序操作让insert数据都写入到尾部，减少阻塞

  - 分解大的操作，降低单个操作的阻塞时间

  - 降低并发数，某些高并发场景通过应用来进行排队机制

  - 对于相对静态的数据，充分利用Query Cache可以极大的提高访问效率
  - MyISAM的Count只有在全表扫描的时候特别高效，带有其他条件的count都需要进行实际的数据访问

### 其他存储引擎

- NDBCluster
- Archive引擎
- Memory引擎

### 如何选择引擎

一般是在InnoDB和MyISAM引擎中选择，如果需要事务，选择InnoDB，如果不需要事务，且主要是select和insert操作，那么可以考虑使用MyISAM。



### 如何知道需要优化哪些sql

- 慢查询日志
- show full processlist
- 抓取tcp网络包



### 剖析单条查询
#### 使用explain

#### 使用show profile

set profiling = 1;

select …..

show profiles;

show profile for query 1


## 高性能

优化方向
1. 减少IO次数
2. 减少cpu计算

优化思路：
库表结构优化，索引优化，查询优化三者齐头并进，才能追求到高性能。
1. schema结构的优化
     字段优化，例如clip url索引改为md5之后再索引，能用small int的就不用int
     分区，数据更聚集
     冗余，减少表关联
     索引优化，尽量用复合索引
2. sql优化
   如何利用索引
   如何利用小表limit出结果后再关联大表获取到最终结果
   like的优化
   order by的优化
   or改为union的优化
3. 最终是通过减少IO次数来提升sql执行效率
4. 减少cpu计算，order by， group by等都是cpu计算大户
5. 优化频繁执行的sql，而不是某些频率低的“大”SQL


# 扩展阅读

- 深入理解MySQL核心技术
    - Sasha Pachev在2000年到2002年期间是MySQL开发团队成员之一
    - 这本书很薄

- 高性能MySQL
    - PeterZaitsev曾经是MySQLAB公司高性能组的经理,  现在是Percona CEO

- 高可用性MySQL
    - CharlesBell
    - Mats Kindahl
    - Lars Thalmann
- MySQL技术内幕:InnoDB存储引擎
    - 姜承尧
- http://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/
- http://www.xaprb.com/blog/2015/08/08/innodb-book-outline/



